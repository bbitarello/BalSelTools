#' Parse VCF files generated by SLiM v3
#'
#' @param infile The path and name of a vcf file - single chromosome
#' @param outfile The path and name for the outfile. If not provided,
#' this will be  a timestamp + infile in the current directory.
#' @param n0 Number of individuals in pop0
#' @param n1 Number of individuals in pop1
#' @param type Which input format will be generated. Options: ncd1, ncd2.
#' @param fold Logical. If TRUE, the output will have alternate allele counts.
#' If FALSE, derived allele counts will be used. Default is TRUE.
#' @param intern Logical. If TRUE, output is kept in R in addition to being written
#' in output file. If FALSE, output is written to file only. Default is TRUE.
#' @param verbose Logical. If TRUE, progress reports will be printed as the
#' function runs.
#'
#' @return Returns a data table object.

#'
#' @examples parse_vcf(infile="inst/example.vcf", outfile="inst/example_parse_ncd1.out", n0=108,  type="ncd1")

parse_vcf_old <-
        function(infile = "*.vcf",
                 outfile = NULL,
                 n0=108,
                 n1=NULL,
                 type = "ncd2",
                 fold = T,
                 intern = T,
                 verbose = T) {
                tictoc::tic("Total runtime")
                assertthat::assert_that(file.exists(infile),
                                        msg = glue::glue("VCF file {infile} does not exist.\n")
                )
                type <- tolower(type)
                # Index No. of the individual to use as ``ancestral'' sequence
                if (fold == F & type == "ncd2") {
                        outseq <- (index.col) + (sum(nind) - 1)
                        if (verbose == T) {
                                cat(
                                        glue::glue(
                                                "You asked for the unfolded version. You need a third species. I will use column {outseq} for this."
                                        ),
                                        "\n"
                                )
                        }
                }else if (type == "ncd2"){
                        assertthat::assert_that(is.null(n1)==FALSE, msg="n1 cannot be NULL. NCD2 requires an outgroup.")
                }
                else if (type == "ncd1") {
                        assertthat::assert_that(fold == T, msg = "Only the folded option is available when Ancestral/Derived states are unknown.\n")
                }
                #
                if (is.null(outfile)) {
                        outfile = outfile_path(glue::glue("{infile}"))
                        if (verbose == T) {
                                cat(
                                        glue::glue(
                                                "No outfile provided. Will write this into tmp file {outfile}_{type}.out"
                                        ),
                                        "\n"
                                )
                        }
                }else{
                        outfile <- glue::glue("{outfile}_{type}.out")
                }

                nind<-c(n0,n1)
                pref <- gsub(".vcf", "", infile)
                inp <- read_vcf(x = infile, only.bi = T)

                index.col <- which(colnames(inp) == "FORMAT") + 1
                if (verbose == T) {
                        cat(
                                glue::glue(
                                        "First genotype column is {index.col}"
                                ), "\n"
                        )
                }
                if (verbose == T) {
                        cat(
                                glue::glue("Creating input file for {type} from {infile}..."),
                                "\n"
                        )
                }


                #
                if (type == "ncd2") {
                        res <-
                                .vcf_ncd2(
                                        x = inp,
                                        outfile = outfile,
                                        nind = nind,
                                        index.col = index.col,
                                        fold = fold,
                                        verbose = verbose
                                )
                } else if (type == "ncd1") {
                        res <-
                                .vcf_ncd1(
                                        x = inp,
                                        outfile = outfile,
                                        nind = nind,
                                        index.col = index.col,
                                        verbose = verbose
                                )
                }
                if (verbose == T) {
                        cat(
                                glue::glue("Finished making input file for {type}. File written to: {outfile}"),
                                "\n"
                        )
                        tictoc::toc()
                } else {
                        cat(glue::glue("File written to: {outfile}"), "\n")
                }

                if (intern == T) {
                        return(res)
                }
        }
#
# out.ncd1.unf<-glue("{outfile}ncd1_unf.out")
# out.ncd2<-glue("{outfile}ncd2")
# out.ncd2.unf<-glue("{outfile}ncd2_unf.out")
# out.betascan<-glue("{outfile}betascan.out")
# out.betascan.unf<-glue("{outfile}betascan_unf.out")
# out.mutebass<-glue("{outfile}mutebass.out")
# out.balmixder<-glue("{outfile}mutebass.out")
# out.ballet.snp<-glue("{outfile}ballet_snp.out")
# out.ballet.rec<-glue("{outfile}ballet_rec.out")
#
# 	for(l in 1:nrow(inp)){
# chr<-inp[l,1]
# pos<-inp[l,2]
# ref<-inp[l,4]
# alt<-inp[l,5]
# anc<-inp[l,get(colnames(inp)[outseq])]
# anc<-str_split(anc,"|",simplify=F)[[1]][[2]]
# drv=0 ; total=0; drv2=0; total2=0
# for(i in index.col:(index.col+nind[1])){
#    al<-str_split(inp[l,get(colnames(inp)[i])],"|",simplify=F)[[1]]
#    if(al[1]!=anc){drv=drv+1}
#      if(al[2]!=anc){drv=drv+1}
# 		      total = total + 2
# 		}
# for(i in ((index.col+nind[1])+1):(index.col+nind[2])){
#    al<-str_split(inp[l,get(colnames(inp)[i])],"|",simplify=F)[[1]]
#   if(al[1]!=anc){drv2=drv2+1}
#    if(al[2]!=anc){drv2=drv2+1}
#     total2 = total2 + 2
# }
# 	sink(out.ncd1)
#  cat("CHR\tPOS\tREF\tALT\tx_1\tn_1\tx_2\tn_2")
#  cat(chr,pos,ref,alt,drv,total, drv2, total2)
# 	sink()
# 		print $1, $2, 1.2e-8*$2,drv,total, drv2, total2 > outmute # recombination rate
#    		print $2, drv,total > betaout
#                if(drv>0) print $2, total-drv, total > balout".snp"
#                if(drv>0){
#                    print $2, ($2-prevpos)*2.75e-4 > balout".rec" # pop-scaled recombination rate (2Nr = 2*11477*1.2e-8 = 2.75448e-4)
#                    prevpos=$2
#                }
#    		if(drv>0) print $2, "NA", drv, total > balmixder #BalLeRMix_manual p.5: When the user does not have recombination maps for reference, the seceond column
# can be NAs as long as the user makes sure to use --physPos.
# }
# }'

# 	sink(out.mutebass)
# 	cat("CHR\tPOS\tGenPOS\tx_1\tn_1\tx_2\tn_2")
# 	sink()
# 	sink(out.balmixder)
# 	cat("physPos\tgenPos\tx\tn")
# 	sync()
# 	sync(out.ballet.snp)
# cat("position\tx\tn")
# sync()
# sync(out.ballet.rec)
# cat("position\trate")
# sync()
# }
# outseq=128
# }
